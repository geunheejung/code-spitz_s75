코드스피치 s75 강의 실습

---- s75 1 - 1/2
# 코드를 작성하기전에 우선적으로 한글로 어떤 코드를 작성할것인지 적자.
# 최대한 할 수 있는대로 코드에 내가 생각하는 바를 최대한 많이 표현하자.
- 즉 주석대신 최대한 변수명의 길이든 코드의 성능이든 상관하지말고 코드에 무조건 의미를 표현하자.
- 한글로 생각한 아주 단순한 로직이라도 코드로 표현하는 훈련을 해야한다.
# 주석으로 표현하는것이 의미가 없는 이유는?
- 코드는 수정되어도, 주석은 같이 수정되지 않는다. 즉 썩는다.
# 함수 또는 객체에서만 사용해야만 하는 즉 자신의 스코프외에서는 사용하기를 원치 않는 또는 내 자신의 내장을 보이기 싫다면은 최대한 숨기도록 노력하자.
- 이 속성에 대한 이 객체값을 남이 건드리는건 싫고 나만 건드리고 싶다면, 어떻게든 내장을 보호하는 방법을 훈련하자.
# 프로그램을 만드는 과정은 '조각'이 아니라 '소조' 에 가깝다.
- 천천히 붙혀나가면서 만드는것이지, 완성된 코드를 깎아내리는것이 아니다. 프로그램은 항상 조심스럽게 살을 붙혀나가는 소조에 가깝다. 즉 프로그램은 처음부터 막 만들어놓고 깎아내가면 망한다.
# 복잡하고 어려운 프로그래밍을 짤 수 있느냐는 한번에 얼마나 여러 생각을 할 수 있느냐?
# 세상에서 들어오는 모든 입력은 다 나를 엿맥일려는것이다. 라고 생각하자.
# javascript의 해체 구문은 key를 못찾을 경우에는 undefined로 처리하지만, 우항의 객체가 해체할 수 없을 경우 throw를 한다. 즉 1차 방어가 들어가있다.
# Class안의 함수들은 함수가 아니라 메서드이다. 그리고 메서드의 기본적인 조건은 인스턴스의 상태를 공유하는 함수의 집합이다. 그러므로 클래스안의 메서드끼리 인자로 보내는것은 잘못된 것이다. 왜냐 메서드이기 때문이다. 바깥에서 호출할 것도 아니고, 외부 입력도 아니기도 때문이다. 인자를 또 보내면 외부에서 온 인자인지 내부에서 화이트리스트 즉 검증된 값인지 알 수 가 없다. 그러므로 메서드끼리는 자신이 속해있는 클래스의 상태를 각각의 메서드에서 사용해야하며, 상태에 저장됬다는것은 검증이 끝난 화이트리스트란 의미이다.
# 코딩을 잘못하는 이유는 인간의 언어를 쓰는것이다. 인간의 언어에 문제점은 많은 의미가 축약된다는것이다. 그러나 프로그래밍은 모든 말들이 다 표현되야한다. 즉 한국어와 코드 사이의 중간언어를 만들어야 한다. 중간언어는 순서가 정확한 한국어로 정하고 코딩의 순서를 인간의 언어 -> 중간언어(의사코드) -> 실제코드 로 가야한다. 이 의사코드는 순서적으로 내 생각을 정리하는데 성공했냐이다.
# 에러의 3단계 
1. 컴파일 에러 - Syntax Error등등
2. 런타임 에러 
3. 컨텍스트 에러
즉 에러를 숨기지말자 왜냐 런타임에러는 잡기가 어렵기 때문이다. 만약 벨리데이션과 같은 에러가 나는 상황에서 throw로 런타임에서 죽이지 않고 감추면 절대 못잡는다.
즉 런타임에러의 전략은 무조건 throw 하자.
만약 이렇게 하지 않으면 컨텍스트 에러 즉 마지막까지 가는데 여기는 에러가 발생해도 에러가 안나고 그대로 계속 진행되는것이다.

# 모든 프로그램은 변한다.
- 이미 작성된 복잡하고 거대한 프로그램을 어떻게 변경할 수 있을 것인가?
- 즉 격리를 잘해야 거대한 프로그램이라 해도 변경할 수 있다.
# 격리 전략
- 변화율에 따라 코드를 작성한다.
ex) load 함수안에 table을 그리는것을 넣지 않고, render함수로 뺀 것
? 데이터를 소비해서 dom 을 그려내는 부분의 변화율과 데이터를 load해서 데이터를 처리하는 부분의 변화률이 완전 다르기 때문이다.
즉 변화율에 따라서 격리를 잘해놔야한다. 그것이 올바른 프로그래밍이다.

#변화율이란 시간적인 대칭성 "변화의 원인과 주기별로 정리" -> 강한 응집성 & 약한 의존성
render함수의 의존성은 약한 의존성이다. parent가 필수적이기 때문이다. 그럼 왜 약한 의존성이라 하나? 의존성이 아예 없을 수 없다. 그래서 필수적으로 parent를 알아야하기에 render 메소드는 약한 의존성이며,
그럼 강한 응집성이란 무엇일까?
load함수를 보면 load함수는 2개의 역할을 한다.
1. 데이터를 네트워크에서 패치해오는 역할과
2. 패치해온 데이터를 벨리데이션 하는 역할을 한다.
그럼 이 load함수는 응집성이 강한것일까?
아니다 load함수는 하나의 함수가 2개의 역할을 하기 때문에 응집성이 강하지 않다.
그럼 강한 응집성이란 무엇일까?
-> 함수 하나가 해당 함수의 역할에 맞게 한가지 역할만 하는것이다.
그러나 우리의 현실이 하나의 역할을 할 수 없는것처럼
프로그램 세계도 단일 역할을 가지기란 어렵다.

---- s75 1 - 2/2
# 역할의 반대는 책임이다.
프로그래밍에서는 이름이 전부이다. 그렇다면 Table 객체는 이름이 Table인데 왜 데이터를 load하는 책임을 져야하는것인가?
즉 Table 객체가 가지고 있는 역할은 현재 
1. 데이터를 load하는 load() 메서드와
2. 데이터를 테이블 Dom Element로 그리는 _render() 메서드인데
Table이라는 객체가 Data를 load하고 올바른 데이터인지 벨리데이션하는것은 Table객체의 책임이 아닌것이다.
여기서 이상한것은 왜 서로 다른 역할인 Data Load와 Rendering 하는 역할을 Table 객체가 다 가지고 있냐는것이다. 이로인해 Data 형식을 json이 아닌 csv 또는 액셀 형태로 바꾸면 Table 객체 자체를 바꿔야 한다는 문제가 발생한다.

# 우리 고객은 적대적인 초딩이다.
적대적인 초딩이 어떤 짓을 하더라도 하는 짓은 뻔한것처럼, 프로그래밍도 작성할 때 고객이 어느 부분을 바꿀지 예상하고 대처를 미리 해놓자.

# 그림을 그리는 Rendering 과 Dom에 그릴지 Canvers에 그릴지에 대한 Native Binding은 분리를 해야한다.
개념적인 그림을 그리고, 실제 시스템에 맞는 그림을 분리해야 시스템 여러개를 소유할 수 있게된다.
Rendering: 개념적인 그림
Native Binding: Table이나 Canvers
위를 Domain Pattern 이라 한다.
Domain과 그의 반대인 Native를 분리하는것.

# 최종적으로 하는 일을 보면 객체의 진정한 역할이 보인다.
// Data Load의 역할이 Data Supply로 바뀜. 왜냐? loader가 최종적으로 하는 일로 보면 Renderer에게 Data를 전해주는 일을 하기 때문이다.
// 즉 Data를 서버에서 load해오든 지역변수값을 주든 밖에서 봤을때는 데이터를 전해주는 역할을 하는것처럼 보이는것이다.
// 즉 loader는 data를 renderer에게 전해줄때 어떤 데이터일지에 대한 방법중 하나인것일뿐이다.

data를 load하는 역할을 Table에서 때내고
Table에서 테이블을 그리는 역할을 
개념적인 그림을 그리는 Renderer와
Table, Canvers를 과 같은 Domain과 상관없는 Native Binding 역할로 분리했을 때
loader에서 data를 load한 다음 renderer에게 전해줬는데
여기서 loader의 최종적으로 하는일을 보면 
Loader는 data를 load 해온 다음 Renderer 에게 전해줬다. 결국 Loader는 Renderer에게 데이터를 전달해주는 역할을 하는 것이다.
그러므로 Loader객체의 역할은 Data Supply 이며, Data를 load하는것은 부가적인 역할일 뿐 인것이다.
즉 Data Supply에서 Data를 json 데이터일지 csv 데이터일지 xml 데이터일지는 각각의 부가적인 역할인것이다. 
즉 Loader 객체는
JsonData 객체
CsvData 객체
XmlData 객체가 되며,
각각의 객체에서 load하는것은 부가적인 역할이다.

그럼 여기서 추상화가 가능한데, 공통 분모인 Data를 추상화 할 수 있다.
즉 Data라는 추상 객체가 있고,
Json, Csv, Xml 서브 객체로 추상화 할 수 있는것이다.
즉 이름이 전부인것이다.
즉 데이터를 로드한다는 본질은 Data로 추상객체에 있고,
각각의 데이터를 파싱한다는것이 다르다.

# 알고리즘도 중요하지만 프로그래밍은 격리(역할, 협력)

#1강 과제 
## 1. 예외의 지점을 찾고 수정하여 완성하라. json 데이터 실제로 적용해보면 에러 발생함.
## 2. 지금까지 전개한 객체협력모델에서는 여전히 문제가 남아있다. Info는 Data와 Renderer 사이에 교환을 위한 프로토콜인데 Data의 자식인 JsonData와 Renderer의 자식인 TableRenderer도 Info에 의존적인 상태이다. 이를 개선하라.








